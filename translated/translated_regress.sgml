```sgml
<chapter>
   <title>회귀 테스트</title>
   <section>
      <title>회귀 테스트</title>
      <para>회귀 테스트는 PostgreSQL의 SQL 구현을 위한 포괄적인 테스트 세트입니다. 이들은 표준 SQL 작업과 PostgreSQL의 확장 기능을 테스트합니다.</para>
   </section>

   <section>
      <title>테스트 실행</title>
      <para>회귀 테스트는 이미 설치되어 실행 중인 서버에 대해 실행하거나 빌드 트리 내의 임시 설치를 사용하여 실행할 수 있습니다. 또한 테스트를 실행하기 위한 병렬 모드와 순차 모드가 있습니다. 순차 방법은 각 테스트 스크립트를 단독으로 실행하는 반면, 병렬 방법은 여러 서버 프로세스를 시작하여 테스트 그룹을 병렬로 실행합니다. 병렬 테스트는 프로세스 간 통신 및 잠금이 올바르게 작동하고 있음을 확인하는 데 신뢰성을 더합니다. 일부 테스트는 테스트에 의해 요구되는 경우 병렬 모드에서도 순차적으로 실행될 수 있습니다.</para>
   </section>

   <section>
      <title>임시 설치에 대한 테스트 실행</title>
      <para>빌드 후 설치 전에 병렬 회귀 테스트를 실행하려면, 다음을 입력하십시오:</para>
      <command>make check</command>
      <para>최상위 디렉토리에서. (또는 <filename>src/test/regress</filename>로 변경하고 그곳에서 명령을 실행할 수 있습니다.) 병렬로 실행되는 테스트는 +로 접두사가 붙고, 순차적으로 실행되는 테스트는 -로 접두사가 붙습니다. 마지막에 다음과 같은 내용을 볼 수 있어야 합니다:</para>
      <quote># 모든 213개의 테스트가 통과했습니다.</quote>
      <para>또는 어떤 테스트가 실패했는지에 대한 노트가 있을 수 있습니다. 실패가 심각한 문제를 나타낸다고 가정하기 전에 아래를 참조하십시오.</para>
      <para>이 테스트 방법은 임시 서버를 실행하므로, 루트 사용자로 빌드를 수행한 경우 작동하지 않습니다. 서버는 루트로 시작되지 않기 때문입니다. 권장 절차는 루트로 빌드를 수행하지 않거나, 설치를 완료한 후 테스트를 수행하는 것입니다.</para>
      <para>PostgreSQL을 이전 PostgreSQL 설치가 이미 존재하는 위치에 설치하도록 구성한 경우, 새로운 버전을 설치하기 전에 <command>make check</command>를 수행하면 테스트가 실패할 수 있습니다. 이는 새로운 프로그램이 이미 설치된 공유 라이브러리를 사용하려고 시도하기 때문입니다. (일반적인 증상은 정의되지 않은 기호에 대한 불만입니다.) 이전 설치를 덮어쓰기 전에 테스트를 실행하려면 <command>configure --disable-rpath</command>로 빌드해야 합니다. 그러나 최종 설치에 이 옵션을 사용하는 것은 권장되지 않습니다.</para>
      <para>병렬 회귀 테스트는 사용자 ID 아래에서 꽤 많은 프로세스를 시작합니다. 현재 최대 동시성은 20개의 병렬 테스트 스크립트이며, 이는 40개의 프로세스를 의미합니다: 각 테스트 스크립트에 대해 서버 프로세스와 psql 프로세스가 있습니다. 따라서 시스템이 사용자당 프로세스 수에 대한 제한을 시행하는 경우, 이 제한이 최소한 50 이상인지 확인하십시오. 그렇지 않으면 병렬 테스트에서 무작위로 보이는 실패가 발생할 수 있습니다. 제한을 높일 수 없는 경우, MAX_CONNECTIONS 매개변수를 설정하여 병렬성의 정도를 줄일 수 있습니다. 예를 들어:</para>
      <command>make MAX_CONNECTIONS=10 check</command>
      <para>는 동시에 10개 이상의 테스트를 실행하지 않습니다.</para>
   </section>

   <section>
      <title>기존 설치에 대한 테스트 실행</title>
      <para>설치 후 테스트를 실행하려면 (참조), 데이터 디렉토리를 초기화하고 <xref>서버</xref>를 시작한 다음 다음을 입력하십시오:</para>
      <command>make installcheck</command>
      <para>또는 병렬 테스트의 경우:</para>
      <command>make installcheck-parallel</command>
      <para>테스트는 기본적으로 로컬 호스트와 기본 포트 번호에서 서버에 연락할 것으로 예상되며, PGHOST 및 PGPORT 환경 변수에 의해 달리 지시되지 않는 한 그렇습니다. 테스트는 회귀라는 이름의 데이터베이스에서 실행됩니다; 이 이름의 기존 데이터베이스는 삭제됩니다.</para>
      <para>테스트는 또한 역할, 테이블스페이스 및 구독과 같은 클러스터 전역 객체를 일시적으로 생성합니다. 이러한 객체는 regress_로 시작하는 이름을 가집니다. 해당 방식으로 이름이 지정된 실제 전역 객체가 있는 설치에서 installcheck 모드를 사용하는 것은 주의하십시오.</para>
   </section>

   <section>
      <title>추가 테스트 스위트</title>
      <para><command>make check</command> 및 <command>make installcheck</command> 명령은 PostgreSQL 서버의 내장 기능을 테스트하는 핵심 회귀 테스트만 실행합니다. 소스 배포에는 선택적 프로시저 언어와 같은 추가 기능과 관련된 많은 추가 테스트 스위트가 포함되어 있습니다.</para>
      <para>구성된 모듈에 적용 가능한 모든 테스트 스위트를 실행하려면, 핵심 테스트를 포함하여 빌드 트리의 최상위에서 다음 명령 중 하나를 입력하십시오:</para>
      <command>make check-world</command>
      <command>make installcheck-world</command>
      <para>이 명령은 이전에 설명한 대로 임시 서버 또는 이미 설치된 서버를 사용하여 테스트를 실행합니다. 다른 고려 사항은 각 방법에 대해 이전에 설명한 것과 동일합니다. <command>make check-world</command>는 각 테스트된 모듈에 대해 별도의 인스턴스(임시 데이터 디렉토리)를 빌드하므로 <command>make installcheck-world</command>보다 더 많은 시간과 디스크 공간이 필요합니다.</para>
      <para>현대 기계에서 여러 CPU 코어가 있고 운영 체제 제한이 엄격하지 않은 경우, 병렬성을 통해 상당히 빠르게 진행할 수 있습니다. 대부분의 PostgreSQL 개발자가 실제로 모든 테스트를 실행하는 데 사용하는 레시피는 다음과 같습니다:</para>
      <command>make check-world -j8 >/dev/null</command>
      <para>-j 제한은 사용 가능한 코어 수와 비슷하거나 약간 더 많습니다. stdout을 버리면 성공을 검증할 때 흥미롭지 않은 잡담이 제거됩니다. (실패의 경우 stderr 메시지는 일반적으로 더 자세히 살펴볼 위치를 결정하는 데 충분합니다.)</para>
      <para>또는 빌드 트리의 적절한 하위 디렉토리에서 <command>make check</command> 또는 <command>make installcheck</command>를 입력하여 개별 테스트 스위트를 실행할 수 있습니다. <command>make installcheck</command>는 관련 모듈이 설치되었다고 가정하므로, 핵심 서버만 설치된 경우에는 사용하지 마십시오.</para>
      <para>이렇게 호출할 수 있는 추가 테스트는 다음을 포함합니다:</para>
      <itemizedlist>
         <listitem>
            <para>선택적 프로시저 언어에 대한 회귀 테스트. 이들은 <filename>src/pl</filename> 아래에 있습니다.</para>
         </listitem>
         <listitem>
            <para>기여 모듈에 대한 회귀 테스트, <filename>contrib</filename> 아래에 위치합니다. 모든 기여 모듈에 테스트가 있는 것은 아닙니다.</para>
         </listitem>
         <listitem>
            <para>인터페이스 라이브러리에 대한 회귀 테스트, <filename>src/interfaces/libpq/test</filename> 및 <filename>src/interfaces/ecpg/test</filename>에 위치합니다.</para>
         </listitem>
         <listitem>
            <para>핵심 지원 인증 방법에 대한 테스트, <filename>src/test/authentication</filename>에 위치합니다. (추가 인증 관련 테스트는 아래를 참조하십시오.)</para>
         </listitem>
         <listitem>
            <para>동시 세션의 동작을 강조하는 테스트, <filename>src/test/isolation</filename>에 위치합니다.</para>
         </listitem>
         <listitem>
            <para>충돌 복구 및 물리적 복제를 위한 테스트, <filename>src/test/recovery</filename>에 위치합니다.</para>
         </listitem>
         <listitem>
            <para>논리적 복제를 위한 테스트, <filename>src/test/subscription</filename>에 위치합니다.</para>
         </listitem>
         <listitem>
            <para>클라이언트 프로그램에 대한 테스트, <filename>src/bin</filename> 아래에 위치합니다.</para>
         </listitem>
      </itemizedlist>
      <para>installcheck 모드를 사용할 때, 이러한 테스트는 회귀를 포함하는 이름의 테스트 데이터베이스를 생성하고 파괴합니다. 예를 들어 <filename>pl_regression</filename> 또는 <filename>contrib_regression</filename>입니다. 해당 방식으로 이름이 지정된 비테스트 데이터베이스가 있는 설치에서 installcheck 모드를 사용하는 것은 주의하십시오.</para>
      <para>이 보조 테스트 스위트 중 일부는 <xref>TAP</xref> 인프라를 사용합니다. TAP 기반 테스트는 PostgreSQL이 <command>--enable-tap-tests</command> 옵션으로 구성된 경우에만 실행됩니다. 이는 개발에 권장되지만, 적절한 Perl 설치가 없는 경우 생략할 수 있습니다.</para>
      <para>일부 테스트 스위트는 기본적으로 실행되지 않으며, 이는 다중 사용자 시스템에서 실행하기에 안전하지 않거나, 특별한 소프트웨어가 필요하거나, 리소스를 많이 소모하기 때문입니다. 추가로 실행할 테스트 스위트를 결정하려면 <command>make</command> 또는 환경 변수 <envar>PG_TEST_EXTRA</envar>를 공백으로 구분된 목록으로 설정하십시오. 예를 들어:</para>
      <command>make check-world PG_TEST_EXTRA='kerberos ldap ssl load_balance libpq_encryption'</command>
      <para>현재 지원되는 값은 다음과 같습니다:</para>
      <itemizedlist>
         <listitem>
            <para><envar>kerberos</envar></para>
            <para>이 테스트 스위트는 <filename>src/test/kerberos</filename> 아래에서 실행됩니다. 이는 MIT Kerberos 설치가 필요하며 TCP/IP 수신 소켓을 엽니다.</para>
         </listitem>
         <listitem>
            <para><envar>ldap</envar></para>
            <para>이 테스트 스위트는 <filename>src/test/ldap</filename> 아래에서 실행됩니다. 이는 OpenLDAP 설치가 필요하며 TCP/IP 수신 소켓을 엽니다.</para>
         </listitem>
         <listitem>
            <para><envar>sepgsql</envar></para>
            <para>이 테스트 스위트는 <filename>contrib/sepgsql</filename> 아래에서 실행됩니다. 이는 특정 방식으로 설정된 SELinux 환경이 필요합니다; 자세한 내용은 <xref>문서</xref>를 참조하십시오.</para>
         </listitem>
         <listitem>
            <para><envar>ssl</envar></para>
            <para>이 테스트 스위트는 <filename>src/test/ssl</filename> 아래에서 실행됩니다. 이는 TCP/IP 수신 소켓을 엽니다.</para>
         </listitem>
         <listitem>
            <para><envar>load_balance</envar></para>
            <para>이 테스트는 <filename>src/interfaces/libpq/t/004_load_balance_dns.pl</filename>를 실행합니다. 이는 시스템 호스트 파일을 편집해야 하며 TCP/IP 수신 소켓을 엽니다.</para>
         </listitem>
         <listitem>
            <para><envar>libpq_encryption</envar></para>
            <para>이 테스트는 <filename>src/interfaces/libpq/t/005_negotiate_encryption.pl</filename>를 실행합니다. 이는 TCP/IP 수신 소켓을 엽니다. <envar>PG_TEST_EXTRA</envar>에 <envar>kerberos</envar>도 포함된 경우, MIT Kerberos 설치가 필요한 추가 테스트가 활성화됩니다.</para>
         </listitem>
         <listitem>
            <para><envar>wal_consistency_checking</envar></para>
            <para>이는 <envar>wal_consistency_checking=all</envar>을 사용하여 <filename>src/test/recovery</filename> 아래의 특정 테스트를 실행합니다. 리소스를 많이 소모하기 때문에 기본적으로 활성화되어 있지 않습니다.</para>
         </listitem>
         <listitem>
            <para><envar>xid_wraparound</envar></para>
            <para>이 테스트 스위트는 <filename>src/test/modules/xid_wraparound</filename> 아래에서 실행됩니다. 리소스를 많이 소모하기 때문에 기본적으로 활성화되어 있지 않습니다.</para>
         </listitem>
      </itemizedlist>
      <para>현재 빌드 구성에서 지원되지 않는 기능에 대한 테스트는 <envar>PG_TEST_EXTRA</envar>에 언급되더라도 실행되지 않습니다.</para>
      <para>또한 <filename>src/test/modules</filename>에 있는 테스트는 <command>make check-world</command>에 의해 실행되지만 <command>make installcheck-world</command>에 의해 실행되지 않습니다. 이는 비생산 확장을 설치하거나 생산 설치에 바람직하지 않은 다른 부작용이 있기 때문입니다. 원하신다면 이러한 하위 디렉토리 중 하나에서 <command>make install</command> 및 <command>make installcheck</command>를 사용할 수 있지만, 비테스트 서버에서 그렇게 하는 것은 권장되지 않습니다.</para>
   </section>

   <section>
      <title>로케일 및 인코딩</title>
      <para>기본적으로 임시 설치를 사용하는 테스트는 현재 환경에서 정의된 로케일과 initdb에 의해 결정된 해당 데이터베이스 인코딩을 사용합니다. 적절한 환경 변수를 설정하여 다양한 로케일을 테스트하는 것이 유용할 수 있습니다. 예를 들어:</para>
      <command>make check LANG=C</command>
      <command>make check LC_COLLATE=en_US.utf8 LC_CTYPE=fr_CA.utf8</command>
      <para>구현 이유로 인해 <envar>LC_ALL</envar>을 설정하는 것은 이 목적에 대해 작동하지 않으며, 다른 모든 로케일 관련 환경 변수는 작동합니다.</para>
      <para>기존 설치에 대해 테스트할 때, 로케일은 기존 데이터베이스 클러스터에 의해 결정되며 테스트 실행을 위해 별도로 설정할 수 없습니다.</para>
      <para>변수 <envar>ENCODING</envar>을 설정하여 데이터베이스 인코딩을 명시적으로 선택할 수도 있습니다. 예를 들어:</para>
      <command>make check LANG=C ENCODING=EUC_JP</command>
      <para>이렇게 데이터베이스 인코딩을 설정하는 것은 일반적으로 로케일이 C일 때만 의미가 있습니다. 그렇지 않으면 인코딩은 로케일에서 자동으로 선택되며, 로케일과 일치하지 않는 인코딩을 지정하면 오류가 발생합니다.</para>
      <para>데이터베이스 인코딩은 임시 또는 기존 설치에 대한 테스트 모두에 대해 설정할 수 있지만, 후자의 경우 설치의 로케일과 호환되어야 합니다.</para>
   </section>

   <section>
      <title>사용자 정의 서버 설정</title>
      <para>테스트 스위트를 실행할 때 사용자 정의 서버 설정을 사용하는 몇 가지 방법이 있습니다. 이는 추가 로깅을 활성화하거나 리소스 제한을 조정하거나 추가 런타임 검사를 활성화하는 데 유용할 수 있습니다. 그러나 모든 테스트가 임의의 설정으로 깨끗하게 통과할 것으로 기대할 수는 없습니다.</para>
      <para>테스트 설정 중 내부적으로 실행되는 다양한 <command>initdb</command> 명령에 추가 옵션을 전달할 수 있습니다. 환경 변수 <envar>PG_TEST_INITDB_EXTRA_OPTS</envar>를 사용하여 예를 들어 체크섬이 활성화된 상태에서 사용자 정의 WAL 세그먼트 크기 및 <envar>work_mem</envar> 설정으로 테스트를 실행하려면:</para>
      <command>make check PG_TEST_INITDB_EXTRA_OPTS='-k --wal-segsize=4 -c work_mem=50MB'</command>
      <para>핵심 회귀 테스트 스위트 및 <command>pg_regress</command>에 의해 구동되는 다른 테스트의 경우, 런타임 서버 설정을 <envar>PGOPTIONS</envar> 환경 변수에 설정할 수도 있습니다(이 설정을 허용하는 경우). 예를 들어:</para>
      <command>make check PGOPTIONS="-c debug_parallel_query=regress -c work_mem=50MB"</command>
      <para>(이는 libpq에서 제공하는 기능을 사용합니다; 자세한 내용은 <xref>문서</xref>를 참조하십시오.)</para>
      <para>임시 설치에 대해 실행할 때, 미리 작성된 <filename>postgresql.conf</filename>를 제공하여 사용자 정의 설정을 설정할 수도 있습니다:</para>
      <command>echo 'log_checkpoints = on' > test_postgresql.conf</command>
      <command>echo 'work_mem = 50MB' >> test_postgresql.conf</command>
      <command>make check EXTRA_REGRESS_OPTS="--temp-config=test_postgresql.conf"</command>
   </section>

   <section>
      <title>추가 테스트</title>
      <para>핵심 회귀 테스트 스위트에는 기본적으로 실행되지 않는 몇 가지 테스트 파일이 포함되어 있습니다. 이는 플랫폼에 따라 다르거나 실행하는 데 매우 오랜 시간이 걸릴 수 있습니다. 이러한 또는 다른 추가 테스트 파일을 실행하려면 변수 <envar>EXTRA_TESTS</envar>를 설정하십시오. 예를 들어, <command>numeric_big</command> 테스트를 실행하려면:</para>
      <command>make check EXTRA_TESTS=numeric_big</command>
   </section>

   <section>
      <title>테스트 평가</title>
      <para>적절하게 설치되고 완전히 기능하는 PostgreSQL 설치는 플랫폼 특정 아티팩트로 인해 일부 회귀 테스트에 실패할 수 있습니다. 예를 들어, 다양한 부동 소수점 표현 및 메시지 단어 선택이 있습니다. 현재 테스트는 참조 시스템에서 생성된 출력과의 간단한 diff 비교를 사용하여 평가되므로 결과는 작은 시스템 차이에 민감합니다. 테스트가 실패로 보고되면 항상 예상 결과와 실제 결과 간의 차이를 검사하십시오. 차이가 중요하지 않을 수 있습니다. 그럼에도 불구하고 모든 지원 플랫폼에서 정확한 참조 파일을 유지하기 위해 노력하고 있으므로 모든 테스트가 통과할 것으로 예상할 수 있습니다.</para>
      <para>회귀 테스트의 실제 출력은 <filename>src/test/regress/results</filename> 디렉토리의 파일에 있습니다. 테스트 스크립트는 diff를 사용하여 각 출력 파일을 <filename>src/test/regress/expected</filename> 디렉토리에 저장된 참조 출력과 비교합니다. 모든 차이는 <filename>src/test/regress/regression.diffs</filename>에 검사할 수 있도록 저장됩니다. (핵심 테스트 외의 테스트 스위트를 실행할 때, 이러한 파일은 물론 관련 하위 디렉토리에 나타납니다, <filename>src/test/regress</filename>가 아닙니다.)</para>
      <para>기본적으로 사용되는 diff 옵션이 마음에 들지 않으면 환경 변수 <envar>PG_REGRESS_DIFF_OPTS</envar>를 설정하십시오. 예를 들어 <envar>PG_REGRESS_DIFF_OPTS='-c'</envar>. (또는 원하신다면 diff를 직접 실행할 수 있습니다.)</para>
      <para>특정 플랫폼에서 특정 테스트에 대해 실패가 발생하더라도, 출력 검토를 통해 결과가 유효하다고 확신할 수 있다면, 향후 테스트 실행에서 실패 보고를 무시하기 위해 새로운 비교 파일을 추가할 수 있습니다. 자세한 내용은 <xref>문서</xref>를 참조하십시오.</para>
   </section>

   <section>
      <title>오류 메시지 차이</title>
      <para>일부 회귀 테스트는 의도적으로 잘못된 입력 값을 포함합니다. 오류 메시지는 PostgreSQL 코드 또는 호스트 플랫폼 시스템 루틴에서 발생할 수 있습니다. 후자의 경우, 메시지는 플랫폼 간에 다를 수 있지만 유사한 정보를 반영해야 합니다. 이러한 메시지의 차이는 실패한 회귀 테스트를 초래할 수 있으며, 검토를 통해 검증할 수 있습니다.</para>
   </section>

   <section>
      <title>로케일 차이</title>
      <para>서버가 C가 아닌 정렬 순서 로케일로 초기화된 경우, 정렬 순서 및 후속 실패로 인해 차이가 발생할 수 있습니다. 회귀 테스트 스위트는 이러한 문제를 처리하기 위해 많은 로케일을 처리할 수 있는 대체 결과 파일을 제공하여 설정되어 있습니다.</para>
      <para>임시 설치 방법을 사용할 때 다른 로케일에서 테스트를 실행하려면, make 명령줄에서 적절한 로케일 관련 환경 변수를 전달하십시오. 예를 들어:</para>
      <command>make check LANG=de_DE.utf8</command>
      <para>(회귀 테스트 드라이버는 <envar>LC_ALL</envar>을 해제하므로, 해당 변수를 사용하여 로케일을 선택하는 것은 작동하지 않습니다.) 로케일을 사용하지 않으려면 모든 로케일 관련 환경 변수를 해제하거나(C로 설정) 다음 특별한 호출을 사용하십시오:</para>
      <command>make check NO_LOCALE=1</command>
      <para>기존 설치에 대해 테스트를 실행할 때, 로케일 설정은 기존 설치에 의해 결정됩니다. 이를 변경하려면, 적절한 옵션을 initdb에 전달하여 데이터베이스 클러스터를 초기화하십시오.</para>
      <para>일반적으로, 생산 사용을 위해 원하는 로케일 설정에서 회귀 테스트를 실행하는 것이 좋습니다. 이는 실제로 생산에서 사용될 로케일 및 인코딩 관련 코드 부분을 실행하게 됩니다. 운영 체제 환경에 따라 실패가 발생할 수 있지만, 적어도 실제 애플리케이션을 실행할 때 기대할 수 있는 로케일 특정 동작을 알 수 있습니다.</para>
   </section>

   <section>
      <title>날짜 및 시간 차이</title>
      <para>대부분의 날짜 및 시간 결과는 시간대 환경에 따라 다릅니다. 참조 파일은 시간대 America/Los_Angeles에 대해 생성되며, 해당 시간대 설정으로 테스트를 실행하지 않으면 명백한 실패가 발생합니다. 회귀 테스트 드라이버는 환경 변수 <envar>PGTZ</envar>를 America/Los_Angeles로 설정하여 일반적으로 올바른 결과를 보장합니다.</para>
   </section>

   <section>
      <title>부동 소수점 차이</title>
      <para>일부 테스트는 테이블 열에서 64비트 부동 소수점 숫자(배정밀도)를 계산하는 것을 포함합니다. 배정밀도 열의 수학적 함수와 관련된 결과에서 차이가 관찰되었습니다. float8 및 geometry 테스트는 플랫폼 간의 작은 차이에 특히 민감하며, 심지어 서로 다른 컴파일러 최적화 설정에서도 차이가 발생할 수 있습니다. 이러한 차이의 실제 중요성을 결정하기 위해서는 사람의 눈으로 비교해야 합니다. 일반적으로 소수점 오른쪽으로 10자리 정도의 차이가 발생합니다.</para>
      <para>일부 시스템은 마이너스 제로를 -0으로 표시하는 반면, 다른 시스템은 단순히 0으로 표시합니다.</para>
      <para>일부 시스템은 pow() 및 exp()에서 오류를 발생시키는 방식이 현재 PostgreSQL 코드에서 예상하는 메커니즘과 다릅니다.</para>
   </section>

   <section>
      <title>행 정렬 차이</title>
      <para>같은 행이 예상 파일에 나타나는 것과 다른 순서로 출력되는 차이를 볼 수 있습니다. 대부분의 경우, 이는 엄밀히 말하면 버그가 아닙니다. 대부분의 회귀 테스트 스크립트는 모든 SELECT에 대해 ORDER BY를 사용하지 않기 때문에 결과 행 정렬이 SQL 사양에 따라 잘 정의되지 않습니다. 실제로, 동일한 데이터에 대해 동일한 소프트웨어로 실행되는 동일한 쿼리를 살펴보면, 모든 플랫폼에서 일반적으로 동일한 결과 정렬을 얻습니다. 따라서 ORDER BY가 없는 것은 문제가 되지 않습니다. 그러나 일부 쿼리는 플랫폼 간 정렬 차이를 보입니다. 이미 설치된 서버에 대해 테스트할 때, 정렬 차이는 비-C 로케일 설정이나 사용자 정의 값의 work_mem 또는 계획 비용 매개변수와 같은 비기본 매개변수 설정으로 인해 발생할 수 있습니다.</para>
      <para>따라서 정렬 차이를 보더라도, 쿼리에 ORDER BY가 있어 결과가 이를 위반하지 않는 한 걱정할 필요는 없습니다. 그러나 여전히 보고해 주십시오. 그렇게 하면 향후 릴리스에서 잘못된 실패를 제거하기 위해 해당 쿼리에 ORDER BY를 추가할 수 있습니다.</para>
      <para>우리가 모든 회귀 테스트 쿼리를 명시적으로 정렬하지 않는 이유가 궁금할 수 있습니다. 그 이유는 그렇게 하면 회귀 테스트가 더 유용하지 않고 덜 유용해지기 때문입니다. 왜냐하면 그렇게 하면 정렬된 결과를 생성하는 쿼리 계획 유형을 배제하게 되기 때문입니다.</para>
   </section>

   <section>
      <title>스택 깊이 부족</title>
      <para>서버가 select infinite_recurse() 명령에서 충돌하는 경우, 이는 플랫폼의 프로세스 스택 크기 제한이 매개변수가 나타내는 것보다 작다는 것을 의미합니다. 이는 서버를 더 높은 스택 크기 제한(기본값인 max_stack_depth에 대해 4MB 권장)으로 실행하여 수정할 수 있습니다. 그렇게 할 수 없는 경우, max_stack_depth의 값을 줄이는 대안이 있습니다.</para>
      <para>getrlimit()를 지원하는 플랫폼에서는 서버가 자동으로 안전한 max_stack_depth 값을 선택해야 하므로, 이 설정을 수동으로 재정의하지 않았다면 이러한 종류의 실패는 보고할 수 있는 버그입니다.</para>
   </section>

   <section>
      <title>무작위 테스트</title>
      <para>무작위 테스트 스크립트는 무작위 결과를 생성하도록 설계되었습니다. 매우 드문 경우에 이로 인해 회귀 테스트가 실패할 수 있습니다. 다음을 입력하면:</para>
      <command>diff results/random.out expected/random.out</command>
      <para>한 줄 또는 몇 줄의 차이만 생성되어야 합니다. 무작위 테스트가 반복적으로 실패하지 않는 한 걱정할 필요는 없습니다.</para>
   </section>

   <section>
      <title>구성 매개변수</title>
      <para>기존 설치에 대해 테스트를 실행할 때, 일부 비기본 매개변수 설정으로 인해 테스트가 실패할 수 있습니다. 예를 들어, enable_seqscan 또는 enable_indexscan과 같은 매개변수를 변경하면 EXPLAIN을 사용하는 테스트의 결과에 영향을 미치는 계획 변경이 발생할 수 있습니다.</para>
   </section>

   <section>
      <title>변형 비교 파일</title>
      <para>일부 테스트는 본질적으로 환경 종속 결과를 생성하므로, 대체 예상 결과 파일을 지정하는 방법을 제공했습니다. 각 회귀 테스트는 서로 다른 플랫폼에서 가능한 결과를 보여주는 여러 비교 파일을 가질 수 있습니다. 각 테스트에 대해 어떤 비교 파일이 사용되는지를 결정하는 두 가지 독립적인 메커니즘이 있습니다.</para>
      <para>첫 번째 메커니즘은 특정 플랫폼에 대해 비교 파일을 선택할 수 있게 합니다. <filename>src/test/regress/resultmap</filename>라는 매핑 파일이 있으며, 각 플랫폼에 대해 사용할 비교 파일을 정의합니다. 특정 플랫폼에 대한 잘못된 테스트 실패를 제거하려면, 먼저 변형 결과 파일을 선택하거나 만들고, 그런 다음 매핑 파일에 줄을 추가합니다.</para>
      <para>매핑 파일의 각 줄은 다음 형식입니다:</para>
      <quote>testname:output:platformpattern=comparisonfilename</quote>
      <para>테스트 이름은 특정 회귀 테스트 모듈의 이름입니다. 출력 값은 확인할 출력 파일을 나타냅니다. 표준 회귀 테스트의 경우, 이는 항상 out입니다. 값은 출력 파일의 파일 확장자에 해당합니다. 플랫폼 패턴은 Unix 도구 expr 스타일의 패턴입니다(즉, 시작 부분에 암시적인 ^ 앵커가 있는 정규 표현식). 이는 config.guess에 의해 인쇄된 플랫폼 이름과 일치합니다. 비교 파일 이름은 대체 결과 비교 파일의 기본 이름입니다.</para>
      <para>예를 들어, 일부 시스템은 작동하는 strtof 함수가 없으며, 우리의 우회 방법은 float4 회귀 테스트에서 반올림 오류를 발생시킵니다. 따라서 이러한 시스템에서 예상되는 결과를 포함하는 변형 비교 파일 <filename>float4-misrounded-input.out</filename>를 제공합니다. Cygwin 플랫폼에서 잘못된 실패 메시지를 무시하기 위해 resultmap에는 다음이 포함됩니다:</para>
      <quote>float4:out:.*-.*-cygwin.*=float4-misrounded-input.out</quote>
      <para>이는 config.guess의 출력이 .*-.*-cygwin.*과 일치하는 모든 머신에서 트리거됩니다. resultmap의 다른 줄은 적절한 다른 플랫폼에 대해 변형 비교 파일을 선택합니다.</para>
      <para>변형 비교 파일을 선택하는 두 번째 메커니즘은 훨씬 더 자동적입니다: 여러 제공된 비교 파일 중에서 가장 잘 일치하는 것을 사용합니다. 회귀 테스트 드라이버 스크립트는 테스트에 대한 표준 비교 파일 <filename>testname.out</filename>과 <filename>testname_digit.out</filename>이라는 변형 파일을 모두 고려합니다(여기서 숫자는 0-9의 단일 숫자입니다). 이러한 파일 중 하나가 정확히 일치하면 테스트는 통과한 것으로 간주됩니다. 그렇지 않으면 가장 짧은 diff를 생성하는 파일이 실패 보고서를 생성하는 데 사용됩니다. (resultmap에 특정 테스트에 대한 항목이 포함된 경우, 기본 테스트 이름은 resultmap에 제공된 대체 이름입니다.)</para>
      <para>예를 들어, char 테스트의 경우, 비교 파일 <filename>char.out</filename>은 C 및 POSIX 로케일에서 예상되는 결과를 포함하고, 파일 <filename>char_1.out</filename>은 많은 다른 로케일에서 나타나는 결과를 정렬하여 포함합니다.</para>
      <para>최고 일치 메커니즘은 로케일 종속 결과를 처리하기 위해 고안되었지만, 테스트 결과를 플랫폼 이름만으로 쉽게 예측할 수 없는 모든 상황에서 사용할 수 있습니다. 이 메커니즘의 제한은 테스트 드라이버가 현재 환경에 대해 실제로 어떤 변형이 올바른지 알 수 없다는 것입니다. 단지 가장 잘 작동하는 변형을 선택할 뿐입니다. 따라서 이 메커니즘은 모든 맥락에서 동등하게 유효하다고 간주할 수 있는 변형 결과에 대해서만 사용하는 것이 가장 안전합니다.</para>
   </section>

   <section>
      <title>TAP 테스트</title>
      <para>다양한 테스트, 특히 <filename>src/bin</filename> 아래의 클라이언트 프로그램 테스트는 Perl TAP 도구를 사용하며 Perl 테스트 프로그램 prove를 사용하여 실행됩니다. prove에 명령줄 옵션을 전달하려면 make 변수 <envar>PROVE_FLAGS</envar>를 설정하십시오. 예를 들어:</para>
      <command>make -C src/bin check PROVE_FLAGS='--timer'</command>
      <para>자세한 내용은 prove의 매뉴얼 페이지를 참조하십시오.</para>
      <para>make 변수 <envar>PROVE_TESTS</envar>는 prove를 호출하는 Makefile에 상대적인 경로의 공백으로 구분된 목록을 정의하는 데 사용될 수 있으며, 기본 t/*.pl 대신 지정된 테스트 하위 집합을 실행합니다. 예를 들어:</para>
      <command>make check PROVE_TESTS='t/001_test1.pl t/003_test3.pl'</command>
      <para>TAP 테스트는 Perl 모듈 IPC::Run이 필요합니다. 이 모듈은 CPAN 또는 운영 체제 패키지에서 사용할 수 있습니다. 또한 PostgreSQL은 <command>--enable-tap-tests</command> 옵션으로 구성되어야 합니다.</para>
      <para>일반적으로 TAP 테스트는 <command>make installcheck</command>를 실행할 경우 이전에 설치된 설치 트리에서 실행되며, <command>make check</command>를 실행할 경우 현재 소스에서 새로운 로컬 설치 트리를 빌드합니다. 두 경우 모두 로컬 인스턴스(데이터 디렉토리)를 초기화하고 그 안에서 서버를 일시적으로 실행합니다. 이러한 테스트 중 일부는 여러 서버를 실행합니다. 따라서 이러한 테스트는 상당히 리소스를 소모할 수 있습니다.</para>
      <para>TAP 테스트는 <command>make installcheck</command>를 실행할 때도 테스트 서버를 시작한다는 점을 인식하는 것이 중요합니다. 이는 기존의 비-TAP 테스트 인프라와 다르며, 이 경우 이미 실행 중인 테스트 서버를 사용해야 합니다. 일부 PostgreSQL 하위 디렉토리에는 전통적인 스타일과 TAP 스타일 테스트가 모두 포함되어 있으며, 이는 <command>make installcheck</command>가 임시 서버와 이미 실행 중인 테스트 서버의 결과를 혼합하여 생성함을 의미합니다.</para>
   </section>

   <section>
      <title>환경 변수</title>
      <para>데이터 디렉토리는 테스트 파일 이름에 따라 명명되며, 테스트가 실패할 경우 유지됩니다. 환경 변수 <envar>PG_TEST_NOCLEAN</envar>이 설정된 경우, 테스트 상태에 관계없이 데이터 디렉토리가 유지됩니다. 예를 들어, pg_dump 테스트를 실행할 때 테스트 결과에 관계없이 데이터 디렉토리를 유지하려면:</para>
      <command>PG_TEST_NOCLEAN=1 make -C src/bin/pg_dump check</command>
      <para>이 환경 변수는 테스트의 임시 디렉토리가 제거되지 않도록 방지합니다.</para>
      <para>테스트 스위트의 많은 작업은 180초 타임아웃을 사용하며, 느린 호스트에서는 부하로 인해 타임아웃이 발생할 수 있습니다. 환경 변수 <envar>PG_TEST_TIMEOUT_DEFAULT</envar>를 더 높은 숫자로 설정하면 기본값을 변경하여 이를 피할 수 있습니다.</para>
   </section>

   <section>
      <title>테스트 커버리지 검사</title>
      <para>PostgreSQL 소스 코드는 커버리지 테스트 계측으로 컴파일할 수 있으므로, 회귀 테스트 또는 코드와 함께 실행되는 다른 테스트에서 어떤 코드 부분이 커버되는지를 검사할 수 있습니다. 이는 현재 GCC로 컴파일할 때 지원되며, gcov 및 lcov 패키지가 필요합니다.</para>
      <para>Autoconf 및 Make로 커버리지</para>
      <para>일반적인 작업 흐름은 다음과 같습니다:</para>
      <command>./configure --enable-coverage ... OTHER OPTIONS ...</command>
      <command>make</command>
      <command>make check # 또는 다른 테스트 스위트</command>
      <command>make coverage-html</command>
      <para>그런 다음 HTML 브라우저를 coverage/index.html로 포인팅하십시오.</para>
      <para>lcov가 없거나 HTML 보고서보다 텍스트 출력을 선호하는 경우, 다음을 실행하여:</para>
      <command>make coverage</command>
      <para>대신 <command>make coverage-html</command>를 실행하면, 테스트와 관련된 각 소스 파일에 대한 .gcov 출력 파일이 생성됩니다. (<command>make coverage</command> 및 <command>make coverage-html</command>는 서로의 파일을 덮어쓰므로 혼합하면 혼란스러울 수 있습니다.)</para>
      <para>커버리지 보고서를 만들기 전에 여러 가지 테스트를 실행할 수 있으며, 실행 횟수가 누적됩니다. 테스트 실행 간에 실행 횟수를 재설정하려면:</para>
      <command>make coverage-clean</command>
      <para>원하는 경우 커버리지 보고서를 위해 코드 트리의 일부에 대해서만 <command>make coverage-html</command> 또는 <command>make coverage</command>를 하위 디렉토리에서 실행할 수 있습니다.</para>
      <para>작업이 끝나면 <command>make distclean</command>을 사용하여 정리하십시오.</para>
      <para>Meson으로 커버리지</para>
      <para>일반적인 작업 흐름은 다음과 같습니다:</para>
      <command>meson setup -Db_coverage=true ... OTHER OPTIONS ... builddir/</command>
      <command>meson compile -C builddir/</command>
      <command>meson test -C builddir/</command>
      <command>cd builddir/</command>
      <command>ninja coverage-html</command>
      <para>그런 다음 HTML 브라우저를 ./meson-logs/coveragereport/index.html로 포인팅하십시오.</para>
      <para>커버리지 보고서를 만들기 전에 여러 가지 테스트를 실행할 수 있으며, 실행 횟수가 누적됩니다.</para>
   </section>
</chapter>
```